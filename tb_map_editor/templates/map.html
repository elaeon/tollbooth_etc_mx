<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Editor</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

<link href="{{ url_for('static', path='/Leaflet.PinSearch.css') }}" rel="stylesheet">
<script src="{{ url_for('static', path='/Leaflet.PinSearch.js') }}" crossorigin=""></script>

<style>
#map { height: 100vh; flex: 1;}
body { height: 100%; display: flex;}
img.huechange_0 { filter: hue-rotate(0deg); }
img.huechange_30 { filter: hue-rotate(60deg); }
div.title-container {
	display: flex; 
	min-width: 160px;
	min-height: 30px;
	justify-content: center;
	font-size: 14px;
}
</style>
</head>

<body>
<div id="map"></div>
<script>

var _tpl_empty_tb_data = null;

const osm = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
	minZoom: 6,
	attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
});

const osmHOT = L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
	minZoom: 6,
	attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Tiles style by <a href="https://www.hotosm.org/" target="_blank">Humanitarian OpenStreetMap Team</a> hosted by <a href="https://openstreetmap.fr/" target="_blank">OpenStreetMap France</a>'
});

const map = L.map('map', {
	center: [21.229471957714843, -104.88745147168034],
	zoom: 10,
	layers: [osm]
});

const addTbLayer = L.layerGroup().addTo(map);
var greenIcon = new L.Icon({
  iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
  iconSize: [20, 36],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [36, 36]
});


function editTbMarker(marker) {
	// remove previous popup and handlers
	marker.unbindPopup();
	marker.bindPopup(createPopupFormHTML(marker));
	marker.off && marker.off('popupopen');
	marker.on('popupopen', (e) => {
		attachPopupFormHandlers(marker.getPopup(), marker);
	});
}


function dragTbMarker(marker) {
	marker.dragging.enable();
	marker.on('dragend', function(e) {
		addInfoPopup(marker, moveOpt=true);
		marker.openPopup();
	});
}


function addInfoPopup(marker, moveOpt) {
	// remove previous popup and handlers
	marker.unbindPopup();
	marker.bindPopup(createInfoPopupHTML(marker, moveOpt));
	marker.off && marker.off('popupopen');
	marker.on('popupopen', (e) => {
		const setLink = e.popup.getElement().querySelector('.set-marker-link');
		const acceptDragLink = e.popup.getElement().querySelector('.accept-move-marker');
		const cancelDragLink = e.popup.getElement().querySelector('.cancel-move-marker');
		if (setLink) {
		 	setLink.addEventListener('click', function(ev) {
				ev.preventDefault();
				//marker.unbindPopup();
				editTbMarker(marker)
				marker.openPopup();
			});
		}
		
		if (acceptDragLink) {
			acceptDragLink.addEventListener('click', async (ev) => {
				const position = marker.getLatLng();
				payload = marker.__data.props;
				payload.tollbooth_id = marker.__data.tollbooth_id;
				payload.lat = position.lat;
				payload.lng = position.lng;
				try {
					const resp = await fetch('/api/tollbooth_upsert/', { 
						method: 'POST', 
						headers: {'Content-Type':'application/json'}, 
						body: JSON.stringify(payload)
					});
					if (!resp.ok) throw new Error(resp.statusText);
					marker.__data.lat = position.lat;
					marker.__data.lng = position.lng;
					//if (status) {
					//status.textContent = 'Saved to server';
					marker.closePopup();
					//}
				} catch(err) { if (status) status.textContent = 'Save error: '+err.message }
			});
		} 

		if (cancelDragLink) {
			cancelDragLink.addEventListener('click', function(ev) {
				ev.preventDefault();
				marker.closePopup();
				const oldPosition = new L.LatLng(marker.__data.lat, marker.__data.lng);
				marker.setLatLng(oldPosition).update();
			});
		}
	});
}


map.on('click', async (e) => {
	const marker = L.marker(e.latlng, {icon: greenIcon, draggable: true});
	marker.__data = { lat: e.latlng.lat, lng: e.latlng.lng, props: {}, setdata: false};

	if (_tpl_empty_tb_data == null) {
		payload = { source: "tollbooth" };
		try {
			const resp = await fetch('/api/empty_data/', { 
				method: 'POST', 
				headers: {'Content-Type':'application/json'}, 
				body: JSON.stringify(payload)
			});
		   	if (!resp.ok) throw new Error(resp.statusText);
		   	if (status) console.log(payload)
		   	_tpl_empty_tb_data = await resp.json();
		} catch(err) { if (status) status.textContent = 'Save error: ' + err.message }
	}
	marker.__data.props = _tpl_empty_tb_data;

	marker.on('dragend', (e) => {
  		//let position = e.target.getLatLng();
		//marker.__data.lat = position.lat;
		//marker.__data.lng = position.lng;
		//marker.__data.setdata = false;
		//addInfoPopup(marker);
		marker.openPopup();
	});

	addInfoPopup(marker, moveOpt=false);
	addTbLayer.clearLayers();
	marker.addTo(addTbLayer);
});

const baseLayers = {
	'OpenStreetMap': osm,
	'OpenStreetMap.HOT': osmHOT
};

const layerControl = L.control.layers(baseLayers).addTo(map);

const ZoomViewer = L.Control.extend({
		onAdd() {
			const container = L.DomUtil.create('div');
			const gauge = L.DomUtil.create('div');
			container.style.width = '200px';
			container.style.background = 'rgba(255,255,255,0.5)';
			container.style.textAlign = 'left';
			map.on('zoomstart zoom zoomend', (ev) => {
				gauge.innerHTML = `Zoom level: ${map.getZoom()}`;
			});
			container.appendChild(gauge);
			return container;
		}
	});


const zoomViewerControl = (new ZoomViewer()).addTo(map);

// PinSearch component
var searchBar = L.control.pinSearch({
            position: 'topright',
            placeholder: 'Search...',
            buttonText: 'Search',
            onSearch: function(query) {
                console.log('Search query:', query);
                // Handle the search query here
            },
            searchBarWidth: '200px',
            searchBarHeight: '30px',
            maxSearchResults: 3
}).addTo(map);

// --- AJAX Query Control for fetching markers ---
// Container styles
const uploadControlStyle = document.createElement('style');
uploadControlStyle.innerHTML = `
	.leaflet-control-query { background: rgba(255,255,255,0.9); padding: 8px; width: 280px; font-size: 13px; z-index: 0;}
	.leaflet-control-query input[type="text"], .leaflet-control-query textarea { width: 100%; box-sizing: border-box; margin-bottom:6px; font-family: monospace; }
	.leaflet-control-query textarea { height: 80px; resize: vertical; }
	.leaflet-control-query button { margin-right:6px; padding: 4px 8px; }
	.leaflet-control-query .status { font-size: 12px; color: #333; margin-top:6px; white-space:pre-wrap; }
`;
document.head.appendChild(uploadControlStyle);

const QueryControl = L.Control.extend({
	onAdd(map) {
		const container = L.DomUtil.create('div', 'leaflet-control-query');
		container.innerHTML = `
			<div><strong>Query & Fetch Markers</strong></div>
			<textarea id="query-input" placeholder="Enter query (JSON or text)"></textarea>
			<select id="query-endpoints">
				<option value="/api/tollbooths">tollbooths</option>
				<option value="/api/tollbooths_sts">tollbooths_sts</option>
				<option value="/api/tollbooths_imt">tollbooths_imt</option>
			</select>
			<label><input id="btn-checkbox-hold" type="checkbox" placeholder="hold markers">Hold markers</label>
			<label>
				<input id="btn-checkbox-change" type="checkbox" placeholder="change marker">
				Change marker
			</label>
			<label>
				<input id="btn-checkbox-edit" type="checkbox" placeholder="edit markers">Edit markers
			</label>
			<div>
				<button id="btn-send-query">Send</button>
				<button id="btn-clear-markers">Clear</button>
			</div>
			<div class="status" id="query-status"></div>
		`;

		L.DomEvent.disableClickPropagation(container);

		const queryInputEl = container.querySelector('#query-input');
		const endpointEl = container.querySelector('#query-endpoints');
		const statusEl = container.querySelector('#query-status');
		const btnSend = container.querySelector('#btn-send-query');
		const btnClear = container.querySelector('#btn-clear-markers');
		const btnCheckboxHold = container.querySelector('#btn-checkbox-hold');
		const btnCheckboxChange = container.querySelector('#btn-checkbox-change');
		const btnCheckboxEdit = container.querySelector('#btn-checkbox-edit');

		btnCheckboxHold.addEventListener('click', async() => {
			uploadedLayer.options.keepLayer = btnCheckboxHold.checked;
			//console.log('Checkbox is ' + uploadedLayer.options.keepLayer);
		});

		btnCheckboxChange.addEventListener('click', async() => {
			uploadedLayer.options.markerColor = "huechange_30";
		});
		
		btnCheckboxEdit.addEventListener('click', async() => {
			// Toggle edit mode for uploaded markers
			uploadedLayer.options.editMode = btnCheckboxEdit.checked;
			// Rebind popups for existing markers according to the new mode
			uploadedLayer.eachLayer(function(layer) {
				try {
					if (!layer || !layer.__data) return;
					if (uploadedLayer.options.editMode) {
						layer.closePopup();
						editTbMarker(layer);
						dragTbMarker(layer);
					} else {
						layer.closePopup();
						addInfoPopup(layer, moveOpt=false);
						layer.dragging.disable();
					}
				} catch (err) {
					console.warn('Error rebinding marker popup', err);
				}
			});
		});

		btnSend.addEventListener('click', async () => {
			const query = queryInputEl.value && queryInputEl.value.trim();
			const endpoint = endpointEl.value && endpointEl.value.trim();
			if (!query) { statusEl.textContent = 'Enter a query'; return; }
			if (!endpoint) { statusEl.textContent = 'Enter an endpoint'; return; }
			
			statusEl.textContent = 'Sending request...';
			try {
				const resp = await fetch(endpoint, {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ query: query })
				});
				if (!resp.ok) throw new Error(`${resp.status} ${resp.statusText}`);
				const data = await resp.json();
				processMarkerResponse(data, query);
			} catch (err) {
				statusEl.textContent = `Error: ${err.message}`;
			}
		});

		btnClear.addEventListener('click', () => {
			btnCheckboxHold.checked = false;
			btnCheckboxChange.checked = false;
			uploadedLayer.options.keepLayer = btnCheckboxHold.checked;
			queryInputEl.value = null;
			uploadedLayer.options.markerColor = "huechange_0";
			clearUploadedMarkers();
			statusEl.textContent = 'Markers cleared';
		});

		return container;
	}
});

// markers layer for fetched data
const uploadedLayer = L.layerGroup().addTo(map);
uploadedLayer.options.keepLayer = false;
// when true, markers show editable form popups; when false show simple info popup
uploadedLayer.options.editMode = false;

function clearUploadedMarkers() {
	if (uploadedLayer.options.keepLayer == false) {
		uploadedLayer.clearLayers();
	}
}

function processMarkerResponse(data, sourceLabel) {
	clearUploadedMarkers();
	const coords = extractCoordinates(data);
	if (!coords.length) throw new Error('No coordinates found in response');
	addMarkersFromCoords(coords, sourceLabel);
	searchBar._populateMarkerLabels(map);
}

function extractCoordinates(data) {
	const coords = [];
	if (!data) return coords;

	// Handle array of objects with lat/lng
	if (Array.isArray(data)) {
		for (const item of data) {
			const c = parseCoordItem(item);
			if (c) coords.push(c);
		}
	}
	// Handle object with data/features/markers array
	else if (typeof data === 'object') {
		for (const key of ['data', 'features', 'markers', 'points', 'coordinates', 'results']) {
			if (Array.isArray(data[key])) {
				for (const item of data[key]) {
					const c = parseCoordItem(item);
					if (c) coords.push(c);
				}
				break;
			}
		}
		// If no array found, try to parse the object itself
		if (!coords.length) {
			const c = parseCoordItem(data);
			if (c) coords.push(c);
		}
	}

	return coords;
}

function parseCoordItem(item) {
	if (!item || typeof item !== 'object') return null;

	let lat, lng, source, tollbooth_id, props = {};

	// Look for lat/lng fields (case insensitive)
	for (const key in item) {
		const lk = key.toLowerCase();
		if (['lat', 'latitude'].includes(lk)) {
			lat = parseFloat(item[key]);
		} else if (['lon', 'longitude', 'lng'].includes(lk)) {
			lng = parseFloat(item[key]);
		} else {
			if (['source'].includes(lk)) {
				source = item[key];
			}
			else {
				if(['tollbooth_id'].includes(lk)) {
					tollbooth_id = item[key];
				}
				else {
					props[key] = item[key];
				}
			}
		}
	}

	if (Number.isFinite(lat) && Number.isFinite(lng) && isValidLat(lat) && isValidLng(lng)) {
		return { lat, lng, source, props, tollbooth_id };
	}
	return null;
}


function addTbMarker(c, sourceLabel) {
	const marker = L.marker([c.lat, c.lng], { title: c.props && (`${c.props.tollbooth_name} [${c.tollbooth_id}]`) || '' });
	// attach original data to marker for use in the popup
	marker.__data = { props: c.props || {}, lat: c.lat, lng: c.lng, source: c.source, query: sourceLabel, tollbooth_id: c.tollbooth_id };
	addInfoPopup(marker, moveOpt=false);
	marker.addTo(uploadedLayer);
	const m_class_color = uploadedLayer.options.markerColor || 'huechange_0';
	if (marker._icon && marker._icon.classList) marker._icon.classList.add(m_class_color);
	return marker;
}


function addMarkersFromCoords(coords, sourceLabel) {
	const markers = [];
	for (const c of coords) {
		if (!isValidLat(c.lat) || !isValidLng(c.lng)) continue;
		const marker = addTbMarker(c, sourceLabel);
		markers.push(marker);
	}
	if (markers.length) {
		const group = L.featureGroup(markers);
		map.fitBounds(group.getBounds(), { maxZoom: 16 });
	}
	const statusEl = document.getElementById('query-status');
	if (statusEl) statusEl.textContent = `Loaded ${markers.length} markers from ${sourceLabel || 'query'}`;
}

// popup form helpers
let _markerFormId = 0;
function escapeHtml(str) {
	return String(str)
		.replace(/&/g, '&amp;')
		.replace(/</g, '&lt;')
		.replace(/>/g, '&gt;')
		.replace(/"/g, '&quot;')
		.replace(/'/g, '&#039;');
}

function createPopupFormHTML(marker) {
	const data = marker.__data;
	const position = marker.getLatLng();
	const id = `marker-form-${++_markerFormId}`;
	const props = data.props || {};
	let html = `<div style="min-width:220px"><form id="${id}" class="marker-form">`;
	html += `<div><strong>Marker data</strong></div>`;
	html += `<input type="hidden" name="lat" value="${escapeHtml(position.lat)}">`;
	html += `<input type="hidden" name="lng" value="${escapeHtml(position.lng)}">`;
	html += `<input type="hidden" name="tollbooth_id" value="${escapeHtml(data.tollbooth_id)}">`;
	for (const key of Object.keys(props)) {
		const val = props[key] == null ? '' : (typeof props[key] === 'object' ? JSON.stringify(props[key]) : String(props[key]));
		html += `<div style="margin:4px 0"><label style="font-size:12px">${escapeHtml(key)}:<br><input name="${escapeHtml(key)}" value="${escapeHtml(val)}" style="width:100%"/></label></div>`;
	}
	if (!Object.keys(props).length) {
		html += `<div style="font-size:12px;color:#666">(no properties)</div>`;
	}
	html += `<div style="margin-top:6px"><button type="submit">Save</button> <button type="button" class="btn-close">Close</button></div>`;
	html += `<div class="form-status" style="margin-top:6px;font-size:12px;color:#333"></div>`;
	html += `</form></div>`;
	return html;
}


// simple non-editable popup showing lat, lng and tollbooth_name (if present)
function createInfoPopupHTML(marker, moveOpt) {
	const data = marker.__data;
	const props = data && data.props ? data.props : null;
	const position = marker.getLatLng();
	let html = '<div style="min-width:160px;font-size:12px">';
	if (data.tollbooth_id) {
		const name = `${escapeHtml(props.tollbooth_name)} [${escapeHtml(data.tollbooth_id)}]`;
		html += `<div class="title-container"><strong>${escapeHtml(String(name || ''))}</strong></div>`;
		if (moveOpt) {
			html += '<div style="display: inline-grid; align-content: center; justify-content: center;">';
			html += '<div><a href="#" class="accept-move-marker">Save here?</a></div>';
			html += '<div><a href="#" class="cancel-move-marker">Cancel</a></div>';
			html += '</div>';
		}
	}
	else {
		html += `<div class="title-container"><a href="#" class="set-marker-link">Add Marker</a></div>`;
	}
	html += `<div>${position.lat}, ${position.lng}</div>`;
	html += '</div>';
	return html;
}



function attachPopupFormHandlers(popup, marker) {
	const el = popup.getElement();
	if (!el) return;
	const form = el.querySelector('form.marker-form');
	if (!form) return;
	const status = el.querySelector('.form-status');
	// prevent attaching multiple times
	if (form._attached) return; form._attached = true;
	form.addEventListener('submit', async (ev) => {
		ev.preventDefault();
		const fd = new FormData(form);
		const obj = {};
		//get data from html form
		for (const [k,v] of fd.entries()) obj[k] = (v === "" ? null : v);
		//update props and exclude hidden values
		marker.__data.props = Object.fromEntries(
  			Object.entries(obj).filter(([key]) => !['lat', 'lng', 'tollbooth_id'].includes(key))
		);
		//update position
		marker.__data.lat = obj.lat;
		marker.__data.lng = obj.lng;
		const payload = { props: obj, source: marker.__data.source, query: marker.__data.query };
		console.log(payload);
		if (status) status.textContent = 'Saved (client-side)';
		try {
			const resp = await fetch('/api/tollbooth_upsert/', { 
				method: 'POST', 
				headers: {'Content-Type':'application/json'}, 
				body: JSON.stringify(payload.props)
			});
			const respData = await resp.json();
		   	if (!resp.ok) throw new Error(resp.statusText);
		   	if (status) {
				status.textContent = 'Saved to server';
				marker.__data.tollbooth_id = respData.tollbooth_id;
				if (addTbLayer.hasLayer(marker)) {
					new_marker = addTbMarker(marker.__data, '');
					addTbLayer.removeLayer(marker);
					uploadedLayer.addLayer(new_marker);
					addInfoPopup(marker, moveOpt=false);
				}
		   	}
		} catch(err) { if (status) status.textContent = 'Save error: '+err.message }
	});
	const btnClose = el.querySelector('.btn-close');
	if (btnClose) btnClose.addEventListener('click', () => {
		marker.closePopup();
		if (!uploadedLayer.options.editMode) {
			addInfoPopup(marker, moveOpt=false);
		}
	});
}

function isValidLat(v) { return Number.isFinite(v) && v >= -90 && v <= 90; }
function isValidLng(v) { return Number.isFinite(v) && v >= -180 && v <= 180; }

// add control to map
(new QueryControl({ position: 'topright' })).addTo(map);

// expose clear function to console for convenience
window.clearUploadedMarkers = clearUploadedMarkers;

</script>

</body>
</html>
