<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Editor</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

<link href="{{ url_for('static', path='/Leaflet.PinSearch.css') }}" rel="stylesheet">
<script src="{{ url_for('static', path='/Leaflet.PinSearch.js') }}" crossorigin=""></script>

<style>
#map { height: 100vh; flex: 1;}
body { height: 100%; display: flex;}
div.title-container {
	display: flex; 
	min-width: 160px;
	min-height: 30px;
	justify-content: center;
	font-size: 14px;
}
</style>
</head>

<body>
<div id="map"></div>
<script>

var _tpl_empty_tb_data = null;

const osm = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
	minZoom: 6,
	maxZoom: 18,
	attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
});

// Esri World Imagery (satellite) - free for non-commercial use per Esri terms
const esriSat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
	minZoom: 0,
	maxZoom: 18,
	attribution: 'Tiles &copy; Esri &mdash; Source: Esri, Maxar, Earthstar Geographics, and the GIS User Community'
});

const map = L.map('map', {
	center: [21.229471957714843, -104.88745147168034],
	zoom: 10,
	layers: [osm]
});


//https://github.com/pointhi/leaflet-color-markers
const greenIcon = new L.Icon({
  iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
  iconSize: [20, 36],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [36, 36]
});


const blueIcon = new L.Icon({
  iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
  iconSize: [20, 36],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [36, 36]
});


const redIcon = new L.Icon({
  iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
  iconSize: [20, 36],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [36, 36]
});

const goldIcon = new L.Icon({
  iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-gold.png',
  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
  iconSize: [20, 36],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [36, 36]
});


const _layers = {
	{% for name, endpoint in query_endpoints.items() %}
	{{ name }}: { layer: L.layerGroup().addTo(map), endpoint: "{{ url_for(endpoint) }}" },
	{% endfor %}
	tmptb: { layer: L.layerGroup().addTo(map), endpoint: null}
};

let _activeLayer = null;
let _tmpMarkerData = null;

function layerIcons() {
	const icons = [blueIcon, goldIcon, redIcon];
	let i = 0;
	for(const layerName in _layers) {
		_layers[layerName].layer.options.markerIcon = icons[i%icons.length];
		i++;
	}
}

window.addEventListener("load", function() {
	_layers.tb.layer.options.editMode = false;
	layerIcons();
	console.log("init settings.");
});


function editTbMarker(marker) {
	// remove previous popup and handlers
	marker.unbindPopup();
	marker.bindPopup(createPopupFormHTML(marker));
	marker.off && marker.off('popupopen');
	marker.on('popupopen', (e) => {
		attachPopupFormHandlers(marker.getPopup(), marker);
	});
}


function dragTbMarker(marker) {
	marker.dragging.enable();
	marker.on('dragend', function(e) {
		addInfoPopup(marker, moveOpt=true);
		marker.openPopup();
	});
}


function addInfoPopup(marker, moveOpt) {
	// remove previous popup and handlers
	marker.unbindPopup();
	marker.bindPopup(createInfoPopupHTML(marker, moveOpt));
	marker.off && marker.off('popupopen');
	marker.on('popupopen', (e) => {
		const setLink = e.popup.getElement().querySelector('.set-marker-link');
		const acceptDragLink = e.popup.getElement().querySelector('.accept-move-marker');
		const cancelDragLink = e.popup.getElement().querySelector('.cancel-move-marker');
		if (setLink) {
		 	setLink.addEventListener('click', function(ev) {
				ev.preventDefault();
				editTbMarker(marker)
				marker.openPopup();
			});
		}
		
		if (acceptDragLink) {
			acceptDragLink.addEventListener('click', async (ev) => {
				const position = marker.getLatLng();
				payload = structuredClone(marker.__data.props);
				payload.tollbooth_id = marker.__data.tollbooth_id;
				payload.lat = position.lat;
				payload.lng = position.lng;
				try {
					const resp = await fetch('{{ url_for("upsert_tollbooth") }}', { 
						method: 'POST', 
						headers: {'Content-Type':'application/json'}, 
						body: JSON.stringify(payload)
					});
					if (!resp.ok) throw new Error(resp.statusText);
					marker.__data.lat = position.lat;
					marker.__data.lng = position.lng;
					//if (status) {
					//status.textContent = 'Saved to server';
					marker.closePopup();
					//}
				} catch(err) { if (status) status.textContent = 'Save error: '+err.message }
			});
		} 

		if (cancelDragLink) {
			cancelDragLink.addEventListener('click', function(ev) {
				ev.preventDefault();
				marker.closePopup();
				const oldPosition = new L.LatLng(marker.__data.lat, marker.__data.lng);
				marker.setLatLng(oldPosition).update();
			});
		}
	});
}


map.on('click', async (e) => {
	let marker = null;
	if (_layers.tmptb.layer.getLayers().length == 0) {
		marker = L.marker(e.latlng, {icon: greenIcon, draggable: true});
		if (_tpl_empty_tb_data == null) {
			payload = { source: "tollbooth" };
			try {
				const resp = await fetch('{{ url_for("get_tb_data") }}', { 
					method: 'POST', 
					headers: {'Content-Type':'application/json'}, 
					body: JSON.stringify(payload)
				});
				if (!resp.ok) throw new Error(resp.statusText);
				if (status) console.log(payload)
				_tpl_empty_tb_data = await resp.json();
			} catch(err) { if (status) status.textContent = 'Save error: ' + err.message }
		}
		marker.__data = { lat: null, lng: null, tollbooth_id: null, props: {} };
		marker.on('dragend', (e) => {
			addInfoPopup(marker);
			marker.openPopup();
		});
		addInfoPopup(marker, moveOpt=false);
		marker.addTo(_layers.tmptb.layer);
	}
	else {
		marker = _layers.tmptb.layer.getLayers()[0];
	}
	marker.setLatLng(new L.LatLng(e.latlng.lat, e.latlng.lng)).update();
	marker.__data.props = structuredClone(_tpl_empty_tb_data);

	if (!_layers[_activeLayer].layer.hasLayer(marker)) {
		marker.addTo(_layers[_activeLayer].layer);
	}
});

const baseLayers = {
	'OpenStreetMap': osm,
	'EsriSatellite': esriSat
};

const layerControl = L.control.layers(baseLayers, {}, { position: 'topleft' }).addTo(map);

// Small control that shows the currently active base layer name
const BaseLayerHint = L.Control.extend({
	onAdd() {
		const container = L.DomUtil.create('div');
		container.style.background = 'rgba(255,255,255,0.9)';
		container.style.padding = '4px 8px';
		container.style.borderRadius = '4px';
		container.style.fontSize = '12px';
		container.style.boxShadow = '0 1px 3px rgba(0,0,0,0.2)';
		container.style.pointerEvents = 'none';
		container.textContent = 'Base: none';
		this._container = container;
		return container;
	},
	update(name) {
		if (!this._container) return;
		this._container.textContent = `Base: ${name}`;
	}
});

const baseHintControl = new BaseLayerHint({ position: 'topleft' }).addTo(map);

// update on layer change
map.on('baselayerchange', (e) => {
	try { baseHintControl.update(e.name || 'unknown'); } catch (err) { console.warn('baseHint update', err); }
});

// set initial value based on which base layer is currently on the map
try {
	let activeName = 'none';
	for (const name in baseLayers) {
		try { if (map.hasLayer(baseLayers[name])) { activeName = name; break; } } catch (e) {}
	}
	baseHintControl.update(activeName);
} catch (err) { console.warn('init baseHint', err); }

const ZoomViewer = L.Control.extend({
		onAdd() {
			const container = L.DomUtil.create('div');
			const gauge = L.DomUtil.create('div');
			container.style.width = '200px';
			container.style.background = 'rgba(255,255,255,0.5)';
			container.style.textAlign = 'left';
			map.on('zoomstart zoom zoomend', (ev) => {
				gauge.innerHTML = `Zoom level: ${map.getZoom()}`;
			});
			container.appendChild(gauge);
			return container;
		}
	});


const zoomViewerControl = (new ZoomViewer()).addTo(map);

// PinSearch component
var searchBar = L.control.pinSearch({
            position: 'topright',
            placeholder: 'Search...',
            buttonText: 'Search',
            onSearch: function(query) {
                console.log('Search query:', query);
                // Handle the search query here
            },
            searchBarWidth: '200px',
            searchBarHeight: '30px',
            maxSearchResults: 3
}).addTo(map);

// --- AJAX Query Control for fetching markers ---
// Container styles
const uploadControlStyle = document.createElement('style');
uploadControlStyle.innerHTML = `
	.leaflet-control-query { background: rgba(255,255,255,0.9); padding: 8px; width: 280px; font-size: 13px; z-index: 0;}
	.leaflet-control-query input[type="text"], .leaflet-control-query textarea { width: 100%; box-sizing: border-box; margin-bottom:6px; font-family: monospace; }
	.leaflet-control-query textarea { height: 80px; resize: vertical; }
	.leaflet-control-query button { margin-right:6px; padding: 4px 8px; }
	.leaflet-control-query .status { font-size: 12px; color: #333; margin-top:6px; white-space:pre-wrap; }
`;
document.head.appendChild(uploadControlStyle);

const QueryControl = L.Control.extend({
	onAdd(map) {
		const container = L.DomUtil.create('div', 'leaflet-control-query');
		container.innerHTML = `
			<div style="display:flex;align-items:center;"><strong>Query & Fetch Markers</strong></div>
			<textarea id="query-input" placeholder="Enter query (JSON or text)"></textarea>
			<select id="query-endpoints">
				{% for name, endpoint in query_endpoints.items() %}
				<option value="{{ url_for(endpoint) }}">{{ name }}</option>
				{% endfor %}
			</select>
			<label>
				<input id="btn-checkbox-edit" type="checkbox" placeholder="edit markers">Edit markers
			</label>
			<div>
				<button id="btn-send-query">Send</button>
				<button id="btn-clear-markers">Clear</button>
				<button id="btn-clear-group-layers">Clear All</button>
			</div>
			<div class="status" id="query-status"></div>
			<div id="marker-props-panel" style="margin-top:8px; max-height:200px; overflow:auto; font-size:12px; background:#f9f9f9; padding:6px; border-radius:4px; display:none"></div>
		`;

		L.DomEvent.disableClickPropagation(container);

		const queryInputEl = container.querySelector('#query-input');
		const endpointEl = container.querySelector('#query-endpoints');
		const statusEl = container.querySelector('#query-status');
		const btnSend = container.querySelector('#btn-send-query');
		const btnClear = container.querySelector('#btn-clear-markers');
		const btnClearAll = container.querySelector('#btn-clear-group-layers');
		const btnCheckboxEdit = container.querySelector('#btn-checkbox-edit');

		// when the endpoint select changes, set `_activeLayer` to the corresponding _layers key (by matching endpoint URL)
		endpointEl.addEventListener('change', () => {
			const val = endpointEl.value;
			let selectedName = null;
			for (const name in _layers) {
				if (_layers[name] && _layers[name].endpoint === val) { selectedName = name; break; }
			}
			_activeLayer = selectedName;
			// toggle visibility: show only the active layer, hide others
			for (const name in _layers) {
				try {
					const lyr = _layers[name] && _layers[name].layer;
					if (!lyr) continue;
					if (name === selectedName) {
						if (!map.hasLayer(lyr)) map.addLayer(lyr);
					} else {
						if (map.hasLayer(lyr)) map.removeLayer(lyr);
					}
				} catch (err) { console.warn('Layer toggle error', err); }
			}
			if (statusEl) statusEl.textContent = `Active layer: ${selectedName || 'none'} ${_layers[_activeLayer].layer.getLayers().length} items`;
		});

		// set initial active layer based on the current select value
		try {
			endpointEl.dispatchEvent(new Event('change'));
		} catch (err) {
			// fallback: compute directly
			const _val = endpointEl.value;
			for (const name in _layers) {
				if (_layers[name] && _layers[name].endpoint === _val) { _activeLayer = name; break; }
			}
			if (statusEl) statusEl.textContent = `Active layer: ${_activeLayer || 'none'} ${_layers[_activeLayer].layer.getLayers().length} items`;
		}

		// btnCheckboxChange.addEventListener('click', async() => {
		// 	uploadedLayer.options.markerColor = "huechange_30";
		// });
		
		btnCheckboxEdit.addEventListener('click', async() => {
			// Toggle edit mode for uploaded markers
			_layers.tb.layer.options.editMode = btnCheckboxEdit.checked;
			// Rebind popups for existing markers according to the new mode
			_layers.tb.layer.eachLayer(function(layer) {
				try {
					if (!layer || !layer.__data) return;
					if (_layers.tb.layer.options.editMode) {
						layer.closePopup();
						editTbMarker(layer);
						dragTbMarker(layer);
					} else {
						layer.closePopup();
						addInfoPopup(layer, moveOpt=false);
						layer.dragging.disable();
					}
				} catch (err) {
					console.warn('Error rebinding marker popup', err);
				}
			});
		});

		btnSend.addEventListener('click', async () => {
			const query = queryInputEl.value && queryInputEl.value.trim();
			const endpoint = endpointEl.value && endpointEl.value.trim();
			if (!query) { statusEl.textContent = 'Enter a query'; return; }
			if (!endpoint) { statusEl.textContent = 'Enter an endpoint'; return; }
			
			statusEl.textContent = 'Sending request...';
			try {
				const resp = await fetch(endpoint, {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ query: query })
				});
				if (!resp.ok) throw new Error(`${resp.status} ${resp.statusText}`);
				const data = await resp.json();
				processMarkerResponse(data, query);
			} catch (err) {
				statusEl.textContent = `Error: ${err.message}`;
			}
		});

		btnClear.addEventListener('click', () => {
			clearMarkers();
			statusEl.textContent = 'Markers cleared';
		});

		btnClearAll.addEventListener('clock', () => {
			queryInputEl.value = null;
			clearAllLayers();
			statusEl.textContent = 'Layers cleared';
		});

		return container;
	}
});


function clearMarkers() {
	try { _layers[_activeLayer].layer.clearLayers(); } catch (e) {}
	const panel = document.getElementById('marker-props-panel');
	if (panel) { panel.style.display = 'none'; panel.innerHTML = ''; }
}

function clearAllLayers() {
	for (const layer in _layers) {
		_layers[layer].layer.clearLayers();
	}
}


function processMarkerResponse(data, sourceLabel) {
	const coords = extractCoordinates(data);
	if (!coords.length) throw new Error('No coordinates found in response');
	addMarkersFromCoords(coords, sourceLabel);
	searchBar._populateMarkerLabels(map);
}

function showMarkerProps(marker) {
	const data = marker.__data;
	const panel = document.getElementById('marker-props-panel');
	if (!panel) return;
	if (!data) { panel.style.display = 'none'; panel.innerHTML = ''; return; }
	const props = data.props || {};
	let html = `<div style="font-weight:600;margin-bottom:6px;display:flex;justify-content:space-between;align-items:center">`;
	html += `<span>Marker properties</span>`;
	html += `<button class="btn-copy-marker" style="padding:2px 8px;font-size:12px;cursor:pointer">Copy</button>`;
	html += `</div>`;
	html += '<table style="width:100%;font-size:12px;border-collapse:collapse">';
	for (const key of Object.keys(props)) {
		const val = props[key] == null ? '' : (typeof props[key] === 'object' ? JSON.stringify(props[key]) : String(props[key]));
		html += `<tr><td style="padding:2px 6px;border-bottom:1px solid #eee;width:40%"><strong>${escapeHtml(key)}</strong></td><td style="padding:2px 6px;border-bottom:1px solid #eee">${escapeHtml(val)}</td></tr>`;
	}
	if (!Object.keys(props).length) html += `<tr><td colspan="2" style="padding:4px;color:#666">(no properties)</td></tr>`;
	html += '</table>';
	panel.innerHTML = html;
	panel.style.display = 'block';
	// attach copy button handler
	const copyBtn = panel.querySelector('.btn-copy-marker');
	if (copyBtn) copyBtn.addEventListener('click', () => { copyMarkerPropsToTemp(marker); });
}

function extractCoordinates(data) {
	const coords = [];
	if (!data) return coords;

	// Handle array of objects with lat/lng
	if (Array.isArray(data)) {
		for (const item of data) {
			const c = parseCoordItem(item);
			if (c) coords.push(c);
		}
	}
	// Handle object with data/features/markers array
	else if (typeof data === 'object') {
		for (const key of ['data', 'features', 'markers', 'points', 'coordinates', 'results']) {
			if (Array.isArray(data[key])) {
				for (const item of data[key]) {
					const c = parseCoordItem(item);
					if (c) coords.push(c);
				}
				break;
			}
		}
		// If no array found, try to parse the object itself
		if (!coords.length) {
			const c = parseCoordItem(data);
			if (c) coords.push(c);
		}
	}

	return coords;
}

function parseCoordItem(item) {
	if (!item || typeof item !== 'object') return null;

	let lat, lng, source, tollbooth_id, props = {};

	// Look for lat/lng fields (case insensitive)
	for (const key in item) {
		const lk = key.toLowerCase();
		if (['lat', 'latitude'].includes(lk)) {
			lat = parseFloat(item[key]);
		} else if (['lon', 'longitude', 'lng'].includes(lk)) {
			lng = parseFloat(item[key]);
		} else {
			if (['source'].includes(lk)) {
				source = item[key];
			}
			else {
				if(['tollbooth_id'].includes(lk)) {
					tollbooth_id = item[key];
				}
				else {
					props[key] = item[key];
				}
			}
		}
	}

	if (Number.isFinite(lat) && Number.isFinite(lng) && isValidLat(lat) && isValidLng(lng)) {
		return { lat, lng, source, props, tollbooth_id };
	}
	return null;
}


function addTbMarker(c, sourceLabel) {
	const marker = L.marker(
		[c.lat, c.lng], 
		{ 
			title: c.props && (`${c.props.tollbooth_name} [${c.tollbooth_id}]`) || '',
			icon: _layers[_activeLayer].layer.options.markerIcon
		}
	);
	// attach original data to marker for use in the popup
	marker.__data = { props: c.props || {}, lat: c.lat, lng: c.lng, source: c.source, query: sourceLabel, tollbooth_id: c.tollbooth_id };
	addInfoPopup(marker, moveOpt=false);
	marker.addTo(_layers[_activeLayer].layer);
	// show properties in QueryControl panel when marker is clicked
	marker.on('click', () => {
		try { showMarkerProps(marker); } catch (err) { console.warn('showMarkerProps error', err); }
	});
	return marker;
}


function addMarkersFromCoords(coords, sourceLabel) {
	const markers = [];
	_layers[_activeLayer].layer.clearLayers();
	for (const c of coords) {
		if (!isValidLat(c.lat) || !isValidLng(c.lng)) continue;
		const marker = addTbMarker(c, sourceLabel);
		markers.push(marker);
	}
	if (markers.length) {
		const group = L.featureGroup(markers);
		map.fitBounds(group.getBounds(), { maxZoom: 16 });
	}
	const statusEl = document.getElementById('query-status');
	if (statusEl) statusEl.textContent = `Loaded ${markers.length} markers from ${sourceLabel || 'query'}`;
}

// popup form helpers
let _markerFormId = 0;
function escapeHtml(str) {
	return String(str)
		.replace(/&/g, '&amp;')
		.replace(/</g, '&lt;')
		.replace(/>/g, '&gt;')
		.replace(/"/g, '&quot;')
		.replace(/'/g, '&#039;');
}

function createPopupFormHTML(marker) {
	const data = marker.__data;
	const position = marker.getLatLng();
	const id = `marker-form-${++_markerFormId}`;
	const props = data.props || {};
	let html = `<div style="min-width:220px"><form id="${id}" class="marker-form">`;
	html += `<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px"><strong>Marker data</strong><button type="button" class="btn-paste-marker" style="padding:2px 8px;font-size:12px;cursor:pointer" ${!_tmpMarkerData ? 'disabled' : ''}>Paste</button></div>`;
	html += `<input type="hidden" name="lat" value="${escapeHtml(position.lat)}">`;
	html += `<input type="hidden" name="lng" value="${escapeHtml(position.lng)}">`;
	html += `<input type="hidden" name="tollbooth_id" value="${escapeHtml(data.tollbooth_id ?? '')}">`;
	for (const key of Object.keys(props)) {
		const val = props[key] == null ? '' : (typeof props[key] === 'object' ? JSON.stringify(props[key]) : String(props[key]));
		html += `<div style="margin:4px 0"><label style="font-size:12px">${escapeHtml(key)}:<br><input name="${escapeHtml(key)}" value="${escapeHtml(val)}" style="width:100%"/></label></div>`;
	}
	if (!Object.keys(props).length) {
		html += `<div style="font-size:12px;color:#666">(no properties)</div>`;
	}
	html += `<div style="margin-top:6px"><button type="submit">Save</button> <button type="button" class="btn-close">Close</button></div>`;
	html += `<div class="form-status" style="margin-top:6px;font-size:12px;color:#333"></div>`;
	html += `</form></div>`;
	return html;
}


// simple non-editable popup showing lat, lng and tollbooth_name (if present)
function createInfoPopupHTML(marker, moveOpt) {
	const data = marker.__data;
	const props = data && data.props ? data.props : null;
	const position = marker.getLatLng();
	let html = '<div style="min-width:160px;font-size:12px">';
	if (data.tollbooth_id) {
		const name = `${escapeHtml(props.tollbooth_name)} [${escapeHtml(data.tollbooth_id)}]`;
		html += `<div class="title-container"><strong>${escapeHtml(String(name || ''))}</strong></div>`;
		if (moveOpt) {
			html += '<div style="display: inline-grid; align-content: center; justify-content: center;">';
			html += '<div><a href="#" class="accept-move-marker">Save here?</a></div>';
			html += '<div><a href="#" class="cancel-move-marker">Cancel</a></div>';
			html += '</div>';
		}
	}
	else {
		html += `<div class="title-container"><a href="#" class="set-marker-link">Add Marker</a></div>`;
	}
	html += `<div>${position.lat}, ${position.lng}</div>`;
	html += '</div>';
	return html;
}

function copyMarkerPropsToTemp(marker) {
	if (!marker || !marker.__data) return;
	_tmpMarkerData = structuredClone(marker.__data);
	alert(`Copied marker data (ID: ${marker.__data.tollbooth_id || 'new'})`);
	// update paste button state in any open form
	const forms = document.querySelectorAll('.btn-paste-marker');
	forms.forEach(btn => { btn.disabled = false; });
}

function pasteMarkerPropsFromTemp(formId) {
	const form = document.getElementById(formId);
	if (!form || !_tmpMarkerData) return;
	const formData = new FormData(form);
	const tmpProps = _tmpMarkerData.props || {};
	for (const key of Object.keys(tmpProps)) {
		const input = form.querySelector(`input[name="${key}"]`);
		if (input) input.value = tmpProps[key] == null ? '' : String(tmpProps[key]);
	}
	//alert('Pasted marker properties');
}


function attachPopupFormHandlers(popup, marker) {
	const el = popup.getElement();
	if (!el) return;
	const form = el.querySelector('form.marker-form');
	if (!form) return;
	const status = el.querySelector('.form-status');
	// prevent attaching multiple times
	if (form._attached) return; form._attached = true;
	
	// attach paste button handler
	const pasteBtn = el.querySelector('.btn-paste-marker');
	if (pasteBtn) pasteBtn.addEventListener('click', () => { pasteMarkerPropsFromTemp(form.id); });
	
	form.addEventListener('submit', async (ev) => {
		ev.preventDefault();
		const fd = new FormData(form);
		const obj = {};
		//get data from html form
		for (const [k,v] of fd.entries()) obj[k] = (v === "" ? null : v);
		//update props and exclude hidden values
		marker.__data.props = Object.fromEntries(
  			Object.entries(obj).filter(([key]) => !['lat', 'lng', 'tollbooth_id'].includes(key))
		);
		//update position
		marker.__data.lat = obj.lat;
		marker.__data.lng = obj.lng;
		obj.tollbooth_id = obj.tollbooth_id === "" ? null : obj.tollbooth_id;
		const payload = { props: obj, source: marker.__data.source, query: marker.__data.query };
		console.log(payload);
		if (status) status.textContent = 'Saved (client-side)';
		try {
			const resp = await fetch('{{ url_for("upsert_tollbooth") }}', { 
				method: 'POST', 
				headers: {'Content-Type':'application/json'}, 
				body: JSON.stringify(payload.props)
			});
			const respData = await resp.json();
		   	if (!resp.ok) throw new Error(resp.statusText);
		   	if (status) {
				status.textContent = 'Saved to server';
				marker.__data.tollbooth_id = respData.tollbooth_id;
				try { showMarkerProps(marker); } catch (err) { console.warn('showMarkerProps error', err); }
				new_marker = addTbMarker(marker.__data, '');
				marker.closePopup();
				addInfoPopup(new_marker, moveOpt=false);
				if (_layers.tmptb.layer.hasLayer(marker)) {
					_layers.tmptb.layer.removeLayer(marker);
				}
				if (_layers[_activeLayer].layer.hasLayer(marker)) {
					_layers[_activeLayer].layer.removeLayer(marker);
				}
		   	}
		} catch(err) { if (status) status.textContent = 'Save error: '+err.message }
	});
	const btnClose = el.querySelector('.btn-close');
	if (btnClose) btnClose.addEventListener('click', () => {
		marker.closePopup();
		if (!_layers.tb.layer.options.editMode) {
			addInfoPopup(marker, moveOpt=false);
		}
	});
}

function isValidLat(v) { return Number.isFinite(v) && v >= -90 && v <= 90; }
function isValidLng(v) { return Number.isFinite(v) && v >= -180 && v <= 180; }

// add control to map
(new QueryControl({ position: 'topright' })).addTo(map);

// expose clear function to console for convenience
window.clearMarkers = clearMarkers;

</script>

</body>
</html>
