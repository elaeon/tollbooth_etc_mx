<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Editor</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

<link href="{{ url_for('static', path='/Leaflet.PinSearch.css') }}" rel="stylesheet">
<script src="{{ url_for('static', path='/Leaflet.PinSearch.js') }}" crossorigin=""></script>

<style>
#map { height: 100vh; flex: 1;}
body { height: 100%; display: flex;}
img.huechange_0 { filter: hue-rotate(0deg); }
img.huechange_30 { filter: hue-rotate(60deg); }
</style>
</head>

<body>
<div id="map"></div>
<script>

const osm = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
	minZoom: 6,
	attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
});

const osmHOT = L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
	minZoom: 6,
	attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Tiles style by <a href="https://www.hotosm.org/" target="_blank">Humanitarian OpenStreetMap Team</a> hosted by <a href="https://openstreetmap.fr/" target="_blank">OpenStreetMap France</a>'
});

const map = L.map('map', {
	center: [21.229471957714843, -104.88745147168034],
	zoom: 10,
	layers: [osm]
});

const baseLayers = {
	'OpenStreetMap': osm,
	'OpenStreetMap.HOT': osmHOT
};

const layerControl = L.control.layers(baseLayers).addTo(map);

const ZoomViewer = L.Control.extend({
		onAdd() {
			const container = L.DomUtil.create('div');
			const gauge = L.DomUtil.create('div');
			container.style.width = '200px';
			container.style.background = 'rgba(255,255,255,0.5)';
			container.style.textAlign = 'left';
			map.on('zoomstart zoom zoomend', (ev) => {
				gauge.innerHTML = `Zoom level: ${map.getZoom()}`;
			});
			container.appendChild(gauge);
			return container;
		}
	});


const zoomViewerControl = (new ZoomViewer()).addTo(map);

// PinSearch component
var searchBar = L.control.pinSearch({
            position: 'topright',
            placeholder: 'Search...',
            buttonText: 'Search',
            onSearch: function(query) {
                console.log('Search query:', query);
                // Handle the search query here
            },
            searchBarWidth: '200px',
            searchBarHeight: '30px',
            maxSearchResults: 3
}).addTo(map);

// --- AJAX Query Control for fetching markers ---
// Container styles
const uploadControlStyle = document.createElement('style');
uploadControlStyle.innerHTML = `
	.leaflet-control-query { background: rgba(255,255,255,0.9); padding: 8px; width: 280px; font-size: 13px; }
	.leaflet-control-query input[type="text"], .leaflet-control-query textarea { width: 100%; box-sizing: border-box; margin-bottom:6px; font-family: monospace; }
	.leaflet-control-query textarea { height: 80px; resize: vertical; }
	.leaflet-control-query button { margin-right:6px; padding: 4px 8px; }
	.leaflet-control-query .status { font-size: 12px; color: #333; margin-top:6px; white-space:pre-wrap; }
`;
document.head.appendChild(uploadControlStyle);

const QueryControl = L.Control.extend({
	onAdd(map) {
		const container = L.DomUtil.create('div', 'leaflet-control-query');
		container.innerHTML = `
			<div><strong>Query & Fetch Markers</strong></div>
			<textarea id="query-input" placeholder="Enter query (JSON or text)"></textarea>
			<select id="query-endpoints">
				<option value="/api/tollbooths">tollbooths</option>
				<option value="/api/tollbooths_sts">tollbooths_sts</option>
				<option value="/api/tollbooths_imt">tollbooths_imt</option>
			</select>
			<label><input id="btn-checkbox-hold" type="checkbox" placeholder="hold markers">Hold markers</label>
			<label>
				<input id="btn-checkbox-change" type="checkbox" placeholder="change marker">
				Change marker
			</label>
			<div>
				<button id="btn-send-query">Send</button>
				<button id="btn-clear-markers">Clear</button>
			</div>
			<div class="status" id="query-status"></div>
		`;

		L.DomEvent.disableClickPropagation(container);

		const queryInputEl = container.querySelector('#query-input');
		const endpointEl = container.querySelector('#query-endpoints');
		const statusEl = container.querySelector('#query-status');
		const btnSend = container.querySelector('#btn-send-query');
		const btnClear = container.querySelector('#btn-clear-markers');
		const btnCheckboxHold = container.querySelector('#btn-checkbox-hold');
		const btnCheckboxChange = container.querySelector('#btn-checkbox-change');

		btnCheckboxHold.addEventListener('click', async() => {
			uploadedLayer.options.keepLayer = btnCheckboxHold.checked;
			//console.log('Checkbox is ' + uploadedLayer.options.keepLayer);
		});

		btnCheckboxChange.addEventListener('click', async() => {
			uploadedLayer.options.markerColor = "huechange_30";
		});

		btnSend.addEventListener('click', async () => {
			const query = queryInputEl.value && queryInputEl.value.trim();
			const endpoint = endpointEl.value && endpointEl.value.trim();
			if (!query) { statusEl.textContent = 'Enter a query'; return; }
			if (!endpoint) { statusEl.textContent = 'Enter an endpoint'; return; }
			
			statusEl.textContent = 'Sending request...';
			try {
				const resp = await fetch(endpoint, {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ query: query })
				});
				if (!resp.ok) throw new Error(`${resp.status} ${resp.statusText}`);
				const data = await resp.json();
				processMarkerResponse(data, query);
			} catch (err) {
				statusEl.textContent = `Error: ${err.message}`;
			}
		});

		btnClear.addEventListener('click', () => {
			btnCheckboxHold.checked = false;
			btnCheckboxChange.checked = false;
			uploadedLayer.options.keepLayer = btnCheckboxHold.checked;
			queryInputEl.value = null;
			uploadedLayer.options.markerColor = "huechange_0";
			clearUploadedMarkers();
			statusEl.textContent = 'Markers cleared';
		});

		return container;
	}
});

// markers layer for fetched data
const uploadedLayer = L.layerGroup().addTo(map);
uploadedLayer.options.keepLayer = false;

function clearUploadedMarkers() {
	if (uploadedLayer.options.keepLayer == false) {
		uploadedLayer.clearLayers();
	}
}

function processMarkerResponse(data, sourceLabel) {
	clearUploadedMarkers();
	const coords = extractCoordinates(data);
	if (!coords.length) throw new Error('No coordinates found in response');
	addMarkersFromCoords(coords, sourceLabel);
}

function extractCoordinates(data) {
	const coords = [];
	if (!data) return coords;

	// Handle array of objects with lat/lon
	if (Array.isArray(data)) {
		for (const item of data) {
			const c = parseCoordItem(item);
			if (c) coords.push(c);
		}
	}
	// Handle object with data/features/markers array
	else if (typeof data === 'object') {
		for (const key of ['data', 'features', 'markers', 'points', 'coordinates', 'results']) {
			if (Array.isArray(data[key])) {
				for (const item of data[key]) {
					const c = parseCoordItem(item);
					if (c) coords.push(c);
				}
				break;
			}
		}
		// If no array found, try to parse the object itself
		if (!coords.length) {
			const c = parseCoordItem(data);
			if (c) coords.push(c);
		}
	}

	return coords;
}

function parseCoordItem(item) {
	if (!item || typeof item !== 'object') return null;

	let lat, lon, source, props = {};

	// Look for lat/lon fields (case insensitive)
	for (const key in item) {
		const lk = key.toLowerCase();
		if (['lat', 'latitude'].includes(lk)) {
			lat = parseFloat(item[key]);
		} else if (['lon', 'longitude'].includes(lk)) {
			lon = parseFloat(item[key]);
		} else {
			if (['source'].includes(lk)) {
				source = item[key];
			}
			else {
				props[key] = item[key];
			}
		}
	}

	if (Number.isFinite(lat) && Number.isFinite(lon) && isValidLat(lat) && isValidLon(lon)) {
		return { lat, lon, source, props };
	}
	return null;
}

function addMarkersFromCoords(coords, sourceLabel) {
	const markers = [];
	for (const c of coords) {
		if (!isValidLat(c.lat) || !isValidLon(c.lon)) continue;
		const m = L.marker([c.lat, c.lon], { title: c.props && c.props.tollbooth_name || '' });
		// attach original data to marker for use in the popup form
		m.__data = { props: c.props || {}, lat: c.lat, lon: c.lon, source: c.source, query: sourceLabel };
		// bind popup with a form populated from props
		m.bindPopup(createPopupFormHTML(m.__data));
		m.on('popupopen', (e) => {
			attachPopupFormHandlers(e.popup, m);
		});
		m.addTo(uploadedLayer);
		const m_class_color = uploadedLayer.options.markerColor || 'huechange_0';
		if (m._icon && m._icon.classList) m._icon.classList.add(m_class_color);
		markers.push(m);
	}
	if (markers.length) {
		const group = L.featureGroup(markers);
		map.fitBounds(group.getBounds(), { maxZoom: 16 });
	}
	const statusEl = document.getElementById('query-status');
	if (statusEl) statusEl.textContent = `Loaded ${markers.length} markers from ${sourceLabel || 'query'}`;
}

// popup form helpers
let _markerFormId = 0;
function escapeHtml(str) {
	return String(str)
		.replace(/&/g, '&amp;')
		.replace(/</g, '&lt;')
		.replace(/>/g, '&gt;')
		.replace(/"/g, '&quot;')
		.replace(/'/g, '&#039;');
}

function createPopupFormHTML(data) {
	const id = `marker-form-${++_markerFormId}`;
	const props = data.props || {};
	let html = `<div style="min-width:220px"><form id="${id}" class="marker-form">`;
	html += `<div><strong>Marker data</strong></div>`;
	html += `<input type="hidden" name="lat" value="${escapeHtml(data.lat)}">`;
	html += `<input type="hidden" name="lon" value="${escapeHtml(data.lon)}">`;
	for (const key of Object.keys(props)) {
		const val = props[key] == null ? '' : (typeof props[key] === 'object' ? JSON.stringify(props[key]) : String(props[key]));
		html += `<div style="margin:4px 0"><label style="font-size:12px">${escapeHtml(key)}:<br><input name="${escapeHtml(key)}" value="${escapeHtml(val)}" style="width:100%"/></label></div>`;
	}
	if (!Object.keys(props).length) {
		html += `<div style="font-size:12px;color:#666">(no properties)</div>`;
	}
	html += `<div style="margin-top:6px"><button type="submit">Save</button> <button type="button" class="btn-close">Close</button></div>`;
	html += `<div class="form-status" style="margin-top:6px;font-size:12px;color:#333"></div>`;
	html += `</form></div>`;
	return html;
}

function attachPopupFormHandlers(popup, marker) {
	const el = popup.getElement();
	if (!el) return;
	const form = el.querySelector('form.marker-form');
	if (!form) return;
	const status = el.querySelector('.form-status');
	// prevent attaching multiple times
	if (form._attached) return; form._attached = true;
	form.addEventListener('submit', async (ev) => {
		ev.preventDefault();
		const fd = new FormData(form);
		const obj = {};
		for (const [k,v] of fd.entries()) obj[k] = v;
		// combine with marker metadata
		const payload = { _lat: marker.__data.lat, _lon: marker.__data.lon, props: obj, source: marker.__data.source, query: marker.__data.query };
		// default action: log to console and show status
		console.log('Marker form submit', payload);
		if (status) status.textContent = 'Saved (client-side)';
		// optionally POST to server: uncomment and change endpoint
		try {
		   const resp = await fetch('/api/tollbooth_update/', { 
			method: 'POST', 
			headers: {'Content-Type':'application/json'}, 
			body: JSON.stringify(payload)
			});
		   if (!resp.ok) throw new Error(resp.statusText);
		   if (status) status.textContent = 'Saved to server';
		} catch(err) { if (status) status.textContent = 'Save error: '+err.message }
	});
	const btnClose = el.querySelector('.btn-close');
	if (btnClose) btnClose.addEventListener('click', () => { map.closePopup(); });
}

function isValidLat(v) { return Number.isFinite(v) && v >= -90 && v <= 90; }
function isValidLon(v) { return Number.isFinite(v) && v >= -180 && v <= 180; }

// add control to map
(new QueryControl({ position: 'topright' })).addTo(map);

// expose clear function to console for convenience
window.clearUploadedMarkers = clearUploadedMarkers;

</script>

</body>
</html>
